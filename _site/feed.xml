<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Iven‘s Blog</title>
    <description>Just go ahead and don&apos;t look back</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 09 Jul 2023 15:20:08 +0800</pubDate>
    <lastBuildDate>Sun, 09 Jul 2023 15:20:08 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>LeetCode 刷题（一）</title>
        <description>&lt;p&gt;#前言
这个暑假在家里闲着也是闲着，准备在LeetCode上每天打卡一道算法题目，学学新的知识，也方便提升一下自己。
今天做的是第15题。
##题目详情
给你一个整数数组 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums&lt;/code&gt; ，判断是否存在三元组&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; [nums[i], nums[j], nums[k]] &lt;/code&gt;满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i != j&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i != k &lt;/code&gt;且 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j != k&lt;/code&gt; ，同时还满足&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; nums[i] + nums[j] + nums[k] == 0 &lt;/code&gt;。请&lt;/p&gt;

&lt;p&gt;你返回所有和为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 且不重复的三元组。&lt;/p&gt;

&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;p&gt;##示例
输入：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums = [-1,0,1,2,-1,-4]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输出：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[-1,-1,2],[-1,0,1]]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 &lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 &lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;不同的三元组是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; [-1,0,1] &lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[-1,-1,2] &lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意，输出的顺序和三元组的顺序并不重要。&lt;/p&gt;

&lt;p&gt;##解题思路&lt;/p&gt;

&lt;p&gt;1.首先我想到的是直接暴力求解，但是当给定的数组到达一定的规模的时候，效率无疑会低很多，我认为暴力求解永远都是存在于最后一个解题思路的方法，因此首先排除。&lt;/p&gt;

&lt;p&gt;2.那么就得从给定数组本身来进行求解，题目给定的数组是无序的，对于相加求和的题目来说，十分不方便，那么便可直接对给定数组进行重新排序，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort&lt;/code&gt;函数即可。&lt;/p&gt;

&lt;p&gt;3.排完序之后，就要按顺序查出给定数组的其中三个元素之和为0的情况。这里使用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;双指针&lt;/code&gt;的方法。&lt;/p&gt;

&lt;p&gt;###双指针&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;双指针方法，是算法题目中较为常见的一种解决方法。其核心思想是在数组中设置两个指针，分别指向数组的头和尾，这样可以同时判定两个元素是否满足题目所要求的条件。在遍历时，设置的终止条件为头指针小于尾指针，每次遍历，依据条件选择让头指针向后移或者尾指针向前移动。 但是，本题所要求的是给定数组中三个元素的和，那么思路就很清晰了：**使用一个单独的指针`k`指向第一个元素，设置双指针法的两个指针分别为`i`、`j`，分别指向`k`后的“头”和“尾”。**意思就是，三元素之和中的固定元素是指针`k`指向的元素，剩下两个元素使用双指针法来遍历。每次双指针法遍历完后，将指针`k`向后移动，重复上述遍历。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;##实现细节&lt;/p&gt;

&lt;p&gt;1.首先是使用指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;对数组进行遍历时，要确定一个终止条件为：如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[k]&amp;gt;0&lt;/code&gt;那么直接终止判断，返回，因为数组已经有序，指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;所指向的元素为三个元素中最小的元素，如果它都大于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，那么比不可能出现三元素之和为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;的情况了。&lt;/p&gt;

&lt;p&gt;2.最重要的一点是&lt;strong&gt;去除重复数组&lt;/strong&gt;，题目所要求的为输出的三元数组，不能包含元素相同的数组，但是给定数组的时候，里面的很多元素是可以重复的，当我们在进行遍历的时候，就会出现相同的三元组，那么就要去除重复的三元组。
###去重
1.首先是在大循环（即用指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;遍历给定数组时），如果指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;向后移动指向的元素与原来的元素数值相同，那么直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt;这次循环，因为得到的三元数组一定是和上一轮得到的三元组相同的结果。&lt;/p&gt;

&lt;p&gt;2.其次，是在双指针遍历时进行去重，样例为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-2,0,0,0,2,2,2&lt;/code&gt;时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;指针指向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-2&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;指针指向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt;指针指向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;。在进行双指针遍历时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;指针向后移动一次或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt;指针向前移动一次，都可以组成三元组，但是三元组与上一轮得到的三元组元素完全相同，每次移动&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;指针或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt;指针之后都要加上一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt;循环判断：如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i]==nums[i-1]&lt;/code&gt;，那么再令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i++&lt;/code&gt;。对于指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt;同理。&lt;/p&gt;

&lt;p&gt;#代码实现
class Solution {
public:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int len=nums.size();//给定数组的长度
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; a;//要求返回的数组
 		int k=0;//作为标准的指针
	if(len&amp;lt;3){
		return a;
	}
    sort(nums.begin(),nums.end());//对给定数组进行从小到大排序
    for(int k=0;k&amp;lt;len;k++){
        if(nums[k]&amp;gt;0){
            return a;
        }
        int i=k+1;//头指针
        int j=len-1;//尾指针
        if(k&amp;gt;0&amp;amp;&amp;amp;nums[k]==nums[k-1]){//标准指针指向的元素与上一个元素相同则去掉，排除重复
            continue;
        }
        while(i&amp;lt;j){//双指针法，左指针一定要小于右指针
            if(nums[i]+nums[j]+nums[k]==0){
            a.push_back({nums[k],nums[i],nums[j]});//若三者相加为0，则加入此三元组
            }
            if(nums[i]+nums[j]+nums[k]&amp;lt;0){//若三者相加小于0，那么就让头指针后移 
            i++;
            continue;
            }
            if(nums[i]+nums[j]+nums[k]&amp;gt;0){//若三者相加大于0，则让尾指针前移
            j--;
            continue;
            }
            i++;
            while(nums[i]==nums[i-1]&amp;amp;&amp;amp;i&amp;lt;j){
            i++;
            }
            j--;                                        
            while(nums[j]==nums[j+1]&amp;amp;&amp;amp;i&amp;lt;j){
            j--;
        }
    }
    }
    return a; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;};&lt;/p&gt;

</description>
        <pubDate>Sun, 09 Jul 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/07/09/LeetCode%E5%88%B7%E9%A2%98-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/07/09/LeetCode%E5%88%B7%E9%A2%98-%E4%B8%80/</guid>
        
        <category>算法</category>
        
        <category>双指针</category>
        
        <category>代码练习</category>
        
        <category>学习记录</category>
        
        
      </item>
    
      <item>
        <title>对于已毕业师兄Blog读后有感</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;今日，偶然间拜读了刚刚毕业离校并入职Alibaba的师兄的个人Blog，有很大触动。&lt;/p&gt;
&lt;h2 id=&quot;感触&quot;&gt;感触&lt;/h2&gt;
&lt;p&gt;很早之前就听闻师兄入职阿里云，我还暗自窃喜，有了SEU的平台拿这些大厂offer不是有手就行？但是，今日一睹师兄的经历，才发现自己大错特错。SEU的研究生可以给我提供一个很广阔的平台，但是仅仅以此而暗自窃喜，这在当前人才辈出的大环境之下无异于自杀。师兄在本科期间便开始记录自己的学习过程，其本科毕业论文便已经是全英文书写，在保研东南后还在字节跳动的网络部门实习了十个月，这已然在同龄人中属于非常优秀的人才了，可今日一睹其Blog，再加上半月之前的毕业聚会，越来越发觉他仍然保持着一颗谦虚，虔诚的内心，这令我非常佩服，也让我坚定了向他学习的决心，在研究生的这条道路上，好好打磨自己，保持谦虚谨慎好学的态度，认真踏实地从事科学研究工作。&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Jul 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/07/07/%E5%AF%B9%E4%BA%8E%E5%B7%B2%E6%AF%95%E4%B8%9A%E5%B8%88%E5%85%84Blog%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/07/07/%E5%AF%B9%E4%BA%8E%E5%B7%B2%E6%AF%95%E4%B8%9A%E5%B8%88%E5%85%84Blog%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/</guid>
        
        <category>感触</category>
        
        <category>奋斗方向</category>
        
        
      </item>
    
      <item>
        <title>无线多跳自组网覆盖测试（一）</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在钢铁厂，由于钢铁阻拦无线信号传播，存在外部无线信号完全无法覆盖的信号密闭区域，例如地下管廊等。计划使用无线多跳自组网进行内部覆盖，并在密闭空间出口连接外部网络。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要构建一个多跳自组织网络。使用4个无线设备（两两进行连接）进行小范围测试，测试网络性能，获得性能参数。&lt;/p&gt;
  &lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
  &lt;p&gt;参考&lt;a href=&quot;https://iven0322.github.io/2023/06/08/%E5%85%B3%E4%BA%8E%E9%A6%99%E6%A9%99%E6%B4%BE-Orange-Pi-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%B5%85%E5%B1%82%E6%AC%A1%E8%AE%A4%E8%AF%86/&quot;&gt;上篇文章&lt;/a&gt;中的各类设备的使用后，今天初步开始了此次实验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;将ubuntu系统烧录进tf卡&quot;&gt;将Ubuntu系统烧录进TF卡&lt;/h3&gt;
&lt;p&gt;1.进入Orange Pi的官方介绍文档下载Zero2所适配的Ubuntu操作系统,其下载后的形式如下图
&lt;img src=&quot;&amp;quot;2023-6-10-1.jpg&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中,每个压缩包都是一个单独的不同版本不同类型的Ubuntu系统,可以选择自己想要的一个系统进行解压,会生成图中的一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.img&lt;/code&gt;结尾的文件,这便是系统的镜像文件.&lt;/p&gt;

&lt;p&gt;2.下载官方烧录软件&lt;a href=&quot;https://www.balena.io/etcher/&quot;&gt;balenaEtcher&lt;/a&gt;,其界面如下图所示:
&lt;img src=&quot;&amp;quot;2023-6-10-2.jpg&amp;quot;&quot; alt=&quot;&quot; /&gt;根据提示选择刚刚解压得到的镜像文件.&lt;/p&gt;

&lt;p&gt;3.利用读卡器,将32GB以上的TH卡与电脑连接,将其确定为目标磁盘,点击直接烧录.
烧录时的场景为:
&lt;img src=&quot;&amp;quot;2023-6-10-3.jpg&amp;quot;&quot; alt=&quot;&quot; /&gt;当进度条为紫色,代表正在烧录.&lt;/p&gt;

&lt;p&gt;balenaEtcher还可以自动检测烧录完的文件是否完整
&lt;img src=&quot;&amp;quot;2023-6-10-4.jpg&amp;quot;&quot; alt=&quot;&quot; /&gt;绿色进度条代表正在验证.&lt;/p&gt;

&lt;p&gt;验证完后,整个烧录过程便至此结束.&lt;/p&gt;

&lt;h3 id=&quot;用ubuntu中控香橙派&quot;&gt;用Ubuntu中控香橙派&lt;/h3&gt;
&lt;p&gt;1.首先将烧录好系统的TF卡插入香橙派,用&lt;a href=&quot;https://iven0322.github.io/2023/06/08/%E5%85%B3%E4%BA%8E%E9%A6%99%E6%A9%99%E6%B4%BE-Orange-Pi-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%B5%85%E5%B1%82%E6%AC%A1%E8%AE%A4%E8%AF%86/&quot;&gt;上篇文章&lt;/a&gt;所展示的连接方法将USB TO TTL与香橙派连接,并连接到电脑上.&lt;/p&gt;

&lt;p&gt;2.下载Windows系统下调试串口的软件&lt;a href=&quot;https://mobaxterm.mobatek.net/&quot;&gt;MobaXterm&lt;/a&gt;,下载后解压并打开软件.
按照下面图示进行操作.
&lt;img src=&quot;&amp;quot;2023-6-10-5.jpg&amp;quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Jun 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/06/10/%E6%97%A0%E7%BA%BF%E5%A4%9A%E8%B7%B3%E8%87%AA%E7%BB%84%E7%BD%91%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95(%E4%B8%80)/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/06/10/%E6%97%A0%E7%BA%BF%E5%A4%9A%E8%B7%B3%E8%87%AA%E7%BB%84%E7%BD%91%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95(%E4%B8%80)/</guid>
        
        <category>Orange Pi</category>
        
        <category>Ubuntu</category>
        
        
      </item>
    
      <item>
        <title>关于香橙派（Orange Pi）开发板的浅层次认识</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;香橙派（Orange Pi）是目前十分前沿也十分流行的嵌入式开发板，针对近期由于芯片研发供应的问题，最受欢迎的嵌入式开发板树莓派已经购买不到，香橙派便成为了树莓派的最佳替代者，两个开发板的操作方法、布局架构等基本一致，因此在开发时所使用的方法也是大同小异。
由于近期我的第一个课题实验提上日程（无线多跳自组网覆盖测试，具体信息会更新在后续Blog中），对于香橙派开发板的研究也就成为了本次科研实验的第一步。&lt;/p&gt;
&lt;h2 id=&quot;香橙派浅谈&quot;&gt;香橙派浅谈&lt;/h2&gt;
&lt;p&gt;本次实验主要使用的香橙派型号是Orange Pi Zero2，搭载了&lt;strong&gt;全志 H616 四核 64 位 1.5GHz 高性能 Cortex-A53 处理器&lt;/strong&gt;，&lt;strong&gt;Mali G31 MP2的GPU&lt;/strong&gt;，包含&lt;strong&gt;TF卡槽&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;香橙派所需要的其他部件&quot;&gt;香橙派所需要的其他部件&lt;/h2&gt;
&lt;p&gt;1.想要在板上对Linux系统进行部署，要准备一个至少&lt;strong&gt;32GB&lt;/strong&gt;的&lt;strong&gt;TF卡&lt;/strong&gt;（推荐闪迪）。&lt;/p&gt;

&lt;p&gt;2.因为Windows PC不能直接对香橙派开发板进行操作，因此首先要将Linux系统或者Android系统烧制到TF卡上，插入香橙派的卡槽方可对其进行调试。有些电脑不能直接插入TF卡，因此要使用读卡器将TF卡转接如PC，这样才能对TF卡进行烧制。&lt;/p&gt;

&lt;p&gt;3.插入TF卡的香橙派开发板相当于没有设置过的小电脑，因此要将其接入PC端必须使用&lt;strong&gt;USB TO TTL转接插头&lt;/strong&gt;，除了转接头要想让香橙派链接到转接头，还需要使用三根&lt;strong&gt;母对母杜邦线&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;连接方法&quot;&gt;连接方法&lt;/h3&gt;
&lt;p&gt;USB TO TTL尾部有五根接头，只需要使用GND、TXD、RXD三根接头，剩下两根3v3和5v在连接香橙派的时候是闲置的。
在香橙派开发板上，USB接口的后面有三根接头，侧边有标志分别为&lt;strong&gt;TXD、RXD以及GND&lt;/strong&gt;。其中，USB TO TTL接口的GND接口与香橙派的GND接口连接，USB TO TTL接口的TXD接口与香橙派的RXD接口连接，USB TO TTL接口的RXD接口与香橙派的TXD接口连接。&lt;/p&gt;

&lt;p&gt;3.因为配置好的香橙派必须要有电源支持，在室外做实验时还需要配备充电宝，香橙派所支持的供电电源是USB转Type-C，因此还需要购买对应数量的&lt;strong&gt;Type-C数据线&lt;/strong&gt;和&lt;strong&gt;充电宝&lt;/strong&gt;用于供电。&lt;/p&gt;

&lt;h2 id=&quot;软件支持&quot;&gt;软件支持&lt;/h2&gt;
&lt;p&gt;1.在对TF卡进行烧录Linux系统时，所需要的软件为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;balenaEtcher&lt;/code&gt;，但是此时读卡器未到，因此并未对其有过多了解，后续会进行深入了解并更新。&lt;/p&gt;

&lt;p&gt;2.在调试香橙派串口的过程中使用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MobaXterm&lt;/code&gt;，此时没有进行到这一步因此并未对其有过多了解，后续会进行深入了解并更新。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Jun 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/06/08/%E5%85%B3%E4%BA%8E%E9%A6%99%E6%A9%99%E6%B4%BE-Orange-Pi-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%B5%85%E5%B1%82%E6%AC%A1%E8%AE%A4%E8%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/06/08/%E5%85%B3%E4%BA%8E%E9%A6%99%E6%A9%99%E6%B4%BE-Orange-Pi-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%B5%85%E5%B1%82%E6%AC%A1%E8%AE%A4%E8%AF%86/</guid>
        
        <category>Orange Pi</category>
        
        <category>嵌入式开发板</category>
        
        
      </item>
    
      <item>
        <title>The First Blog</title>
        <description>&lt;h2 id=&quot;blog-诞生纪念&quot;&gt;Blog 诞生纪念&lt;/h2&gt;
&lt;p&gt;2023年，这一年是个值得纪念的一年，我在南京理工大学的四年本科生涯彻底结束了，我也即将在东南大学迎来人生中的新一轮挑战。
未来尽是未知，但冥冥之中我知道未来的三年会是我一生中最重要的一站，希望我能用此Blog记录我的经历、学习与成长。&lt;/p&gt;
&lt;h2 id=&quot;感恩&quot;&gt;感恩&lt;/h2&gt;
</description>
        <pubDate>Tue, 06 Jun 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/06/06/Blog%E7%BA%AA%E5%BF%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/06/06/Blog%E7%BA%AA%E5%BF%B5/</guid>
        
        <category>展望</category>
        
        <category>期待</category>
        
        <category>纪念</category>
        
        
      </item>
    
      <item>
        <title>KVO详解</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;作为一名iOS开发者，最近面试被问到了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt;的问题。其实&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt;的原理以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runtiem&lt;/code&gt;的知识，很早之前就有学习和使用了，但是实现的细节都忘记差不多了，故再此重新梳理一下。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKeyValueObserving &lt;/code&gt;，一种非正式协议，通知其他对象的指定属性发生了改变。&lt;/p&gt;

&lt;p&gt;简单理解就是，监听一个对象的某个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;属性&lt;/code&gt;是否发生改变。&lt;/p&gt;

&lt;h3 id=&quot;kvo的使用&quot;&gt;KVO的使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;监听某个对象的某个属性&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;keyPath&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;实现非正式协议&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;observeValueForKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;keyPath&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ofObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueChangeKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;change&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;移除监听&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;keyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码演示&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BYPersonModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;Tony Qiu&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;/// 添加监听&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;/// options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld 监听新值和旧值,若不传则在监听方法中，无法捕获变化的值&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptionNew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptionOld&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;age&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptionNew&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;/// 改变属性值 就能在监听中捕获变化&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;Peng YuYan&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;/// 在非正式协议里监听对象变化&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;observeValueForKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;keyPath&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ofObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueChangeKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;change&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;/// 移除监听&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dealloc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2021-03-19 14:35:02.814222+0800 KVO_demo[34947:1626934] {
    kind = 1;
    new = &quot;Peng YuYan&quot;;
    old = &quot;Tony Qiu&quot;;
}
2021-03-19 14:35:02.814448+0800 KVO_demo[34947:1626934] {
    kind = 1;
    new = 28;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;kvo底层实现&quot;&gt;KVO底层实现&lt;/h3&gt;

&lt;p&gt;首先，我们用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runtime&lt;/code&gt;在添加监听之前和之后分别打印一下类对象&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object_getClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptionNew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptionOld&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object_getClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KVO_demo[75775:1761189] BYPersonModel
KVO_demo[75775:1761189] NSKVONotifying_BYPersonModel

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;也可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lldb&lt;/code&gt; 中打印,&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;不能打印 [self.personModel class],后面会说到为什么&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) po self.personModel.isa
BYPersonModel

  Fix-it applied, fixed expression was: 
    self.personModel-&amp;gt;isa
(lldb) po self.personModel.isa
NSKVONotifying_BYPersonModel

  Fix-it applied, fixed expression was: 
    self.personModel-&amp;gt;isa
(lldb) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;会发现添加监听后的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;personModel&lt;/code&gt;的类从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYPersonModel&lt;/code&gt; 变成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKVONotifying_BYPersonModel&lt;/code&gt;，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKVONotifying_+类名&lt;/code&gt;的形式。
就是说系统为我们自动生创建了一个新的类，然后通过这个类去实现监听方法。&lt;/p&gt;

&lt;p&gt;进一步验证，我们自己创建一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKVONotifying_BYPersonModel&lt;/code&gt;类，添加KVO时，会发出警告&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KVO_demo[19623:258692] BYPersonModel
KVO_demo[19623:258692] [general] KVO failed to allocate class pair for name NSKVONotifying_BYPersonModel, automatic key-value observing will not work for this class
KVO_demo[19623:258692] BYPersonModel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并且系统无法自动生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKVONotifying_BYPersonModel&lt;/code&gt;类。&lt;/p&gt;

&lt;p&gt;下面我们使用下面打印&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKVONotifying_BYPersonModel&lt;/code&gt;的属性和方法&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;/// 打印方法&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;methodsByClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@ methods:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methods&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class_copyMethodList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSStringFromSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method_getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;/// 打印属性&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ivarsByClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@ ivars:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Ivar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivars&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class_copyIvarList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Ivar&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ivar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ivars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivarName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stringWithUTF8String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivar_getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//获取成员变量的名字&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivarType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stringWithUTF8String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivar_getTypeEncoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//获取成员变量的数据类型&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@ %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ivarName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ivarType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KVO_demo[16813:215245] NSKVONotifying_BYPersonModel methods:
KVO_demo[16813:215245] setName:
KVO_demo[16813:215245] class
KVO_demo[16813:215245] dealloc
KVO_demo[16813:215245] _isKVOA
KVO_demo[16813:215245] NSKVONotifying_BYPersonModel ivars:

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;观察可以发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKVONotifying_BYPersonModel&lt;/code&gt; 没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ivar&lt;/code&gt;。
重写了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setName &lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class &lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dealloc &lt;/code&gt;方法，还新增了一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_isKVOA&lt;/code&gt;方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_isKVOA&lt;/code&gt;用来判断是否是系统生成的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setName:&lt;/code&gt;重写Set方法，并发送监听&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; 返回父类，隐藏系统生成的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSKVONotifying_类&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dealloc&lt;/code&gt;销毁时移除一些方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;我们来看看重写的set方法做了什么&quot;&gt;我们来看看重写的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;方法做了什么&lt;/h4&gt;

&lt;p&gt;打断点，用户 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lldb&lt;/code&gt;打印 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt;前后的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setName:&lt;/code&gt;方法&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) p [self.personModel methodForSelector:@selector(setName:)]
(IMP) $1 = 0x00000001059aef00 (KVO_demo`-[BYPersonModel setName:] at BYPersonModel.h:14)
(lldb) p [self.personModel methodForSelector:@selector(setName:)]
(IMP) $2 = 0x00007fff207d2583 (Foundation`_NSSetObjectValueAndNotify)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先可以发现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setName:&lt;/code&gt;方法的指针指向变了，从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[BYPersonModel setName:]&lt;/code&gt;指向了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foundation &lt;/code&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_NSSetObjectValueAndNotify&lt;/code&gt;的C语言方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_NSSetObjectValueAndNotify&lt;/code&gt;内部做了什么呢？通过越狱手机可以获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foundation&lt;/code&gt;框架，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hopper&lt;/code&gt;来解析源码生成的是汇编语言，看看汇编源码会发现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_NSSetObjectValueAndNotify&lt;/code&gt;内部注释有提示说调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;didChangeValueForKey&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;尝试手动触发一个kvo&quot;&gt;尝试手动触发一个KVO&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    [self.personModel willChangeValueForKey:@&quot;name&quot;];
    [self.personModel didChangeValueForKey:@&quot;name&quot;];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;直接调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;willChangeValueForKey:&lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;didChangeValueForKey:&lt;/code&gt;后，能发现触发了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO &lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observeValueForKeyPath&lt;/code&gt;方法。
单独调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;willChangeValueForKey:&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;didChangeValueForKey:&lt;/code&gt;，则不会触发。&lt;/p&gt;

&lt;p&gt;这就验证了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_NSSetObjectValueAndNotify&lt;/code&gt; 的一些内部操作。&lt;/p&gt;

&lt;h4 id=&quot;到此整个kvo流程基本上就清晰了&quot;&gt;到此整个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt;流程基本上就清晰了：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/21/165fb89bc6ba9262?w=1878&amp;amp;h=898&amp;amp;f=png&amp;amp;s=150722&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;动态生成一个自己的类&quot;&gt;动态生成一个自己的类&lt;/h3&gt;

&lt;p&gt;通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt; 底层的学习，我们知道了如何动态生成一个自己的类。&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;creatClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;/// 创建类&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objc_allocateClassPair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;BYCustomClass&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;/// 添加实例变量和方法&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;class_addIvar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;i&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;class_addIvar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;log2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;/// 添加方法，`V@:`表示方法的参数和返回值&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;class_addMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gohome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IMP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gohome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;V@:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;/// 注册到运行时环境(注意：注册后无法再添加方法和实例变量)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;objc_registerClassPair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gohome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;回家了&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gohome&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自己写一个kvo&quot;&gt;自己写一个KVO&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt;的原理知道了，我们尝试自己写一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KVO&lt;/code&gt;吧&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;kvo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;/// 添加一个KVO方法&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;by_addObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;keyPath&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;下面代码运行会报错 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Build Settings&lt;/code&gt; 中设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENABLE_STRICT_OBJC_MSGSEND = NO&lt;/code&gt;即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#import &quot;NSObject+kvo.h&quot;
#import &amp;lt;objc/runtime.h&amp;gt;
#import &amp;lt;objc/message.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;kvo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;by_addObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;keyPath&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//动态添加一个类&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSStringFromClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;BY_NSKVONotifying_&quot;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stringByAppendingString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originClassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 继承自当前类，创建一个子类，类名模仿KVO底层命名 BY_NSKVONotifying_+类名的形式&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kvoClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objc_allocateClassPair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newClassName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UTF8String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 添加setter方法 这里我们只监听 name，手动添加setName方法。&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// v@:@：v 对应setName方法的返回值void，@: 表示方法本身，@ 表示参数是个对象&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;class_addMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kvoClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IMP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;v@:@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;//注册新添加的这个类&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;objc_registerClassPair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kvoClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 修改isa指针，由 personModel 指向我们创建的 BY_NSKVONotifying_BYPrsonModel 对象实现替换&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;object_setClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kvoClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 保存观察者属性到当前类中&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;objc_setAssociatedObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;observer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OBJC_ASSOCIATION_RETAIN_NONATOMIC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#pragma mark - 重写父类方法
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 保存当前KVO的类&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kvoClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 将self的isa指针指向父类BYPersonModel，调用父类setter方法&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;object_setClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class_getSuperclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 获取BY_NSKVONotifying_BYPrsonModel观察者&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objc_getAssociatedObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;observer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 通知观察者，执行通知方法&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueChangeKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;change&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;@{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;kind&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;@1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;new&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observeValueForKeyPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ofObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 将指针重新指向 BY_NSKVONotifying_BYPrsonModel&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;object_setClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kvoClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用我们的kvo方法&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BYPersonModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;Tony Qiu&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object_getClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;by_addObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptionNew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSKeyValueObservingOptionOld&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object_getClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KVO_demo[51608:1429122] BYPersonModel
KVO_demo[51608:1429122] BY_NSKVONotifying_BYPersonModel
KVO_demo[51608:1429122] {
    kind = 1;
    new = &quot;Peng YuYan&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYPersonModel&lt;/code&gt;类被替换成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BY_NSKVONotifying_BYPersonModel&lt;/code&gt;类，也能监听到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;的变化，手写KVO成功。
当然实际的KVO实现的细节远比我们手写的复杂，这个只是一探究竟而已。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA&quot;&gt;《Introduction to Key-Value Observing Programming Guide》
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;https://blog.csdn.net/science_lee/article/details/82843080&lt;/li&gt;
  &lt;li&gt;https://www.cenzhijun.top/2018/05/kvo/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 29 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/03/29/KVO%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/29/KVO%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>ReactiveCocoa 进阶</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;在&lt;a href=&quot;http://qiubaiying.github.io/2016/12/26/ReactiveCocoa-基础/&quot;&gt;上篇文章&lt;/a&gt;中介绍了&lt;strong&gt;ReactiveCocoa&lt;/strong&gt;的基础知识,接下来我们来深入介绍&lt;strong&gt;ReactiveCocoa&lt;/strong&gt;及其在&lt;strong&gt;MVVM&lt;/strong&gt;中的用法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fbgye3re5xj30je0iomz8.jpg&quot; alt=&quot;ReactiveCocoa进阶思维导图&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;常见操作方法介绍&quot;&gt;常见操作方法介绍&lt;/h1&gt;

&lt;h4 id=&quot;操作须知&quot;&gt;操作须知&lt;/h4&gt;

&lt;p&gt;所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，因此只要继承RACStream就有了操作处理方法。&lt;/p&gt;
&lt;h4 id=&quot;操作思想&quot;&gt;操作思想&lt;/h4&gt;

&lt;p&gt;运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.&lt;/p&gt;

&lt;p&gt;Hook用处：截获API调用的技术。&lt;/p&gt;

&lt;p&gt;有关Hook的知识可以看我的这篇博客&lt;a href=&quot;http://www.jianshu.com/p/ff114e69cc0a&quot;&gt;《Objective-C Runtime 的一些基本使用》&lt;/a&gt;中的 &lt;em&gt;更换代码的实现方法&lt;/em&gt; 一节,&lt;/p&gt;

&lt;p&gt;Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。&lt;/p&gt;

&lt;h4 id=&quot;操作方法&quot;&gt;操作方法&lt;/h4&gt;

&lt;h4 id=&quot;bind绑定--reactivecocoa核心方法&quot;&gt;&lt;strong&gt;bind&lt;/strong&gt;（绑定）- ReactiveCocoa核心方法&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;ReactiveCocoa&lt;/strong&gt; 操作的核心方法是 &lt;strong&gt;bind&lt;/strong&gt;（绑定）,而且也是RAC中核心开发方式。之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。&lt;/p&gt;

&lt;p&gt;列如，把数据展示到控件上，之前都是重写控件的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setModel&lt;/code&gt; 方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;RAC底层都是调用&lt;strong&gt;bind&lt;/strong&gt;， 在开发中很少直接使用 &lt;strong&gt;bind&lt;/strong&gt; 方法，&lt;strong&gt;bind&lt;/strong&gt;属于RAC中的底层方法，我们只需要调用封装好的方法，&lt;strong&gt;bind&lt;/strong&gt;用作了解即可.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;bind方法使用步骤&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;传入一个返回值 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACStreamBindBlock&lt;/code&gt; 的 block。&lt;/li&gt;
      &lt;li&gt;描述一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACStreamBindBlock&lt;/code&gt; 类型的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt;作为block的返回值。&lt;/li&gt;
      &lt;li&gt;描述一个返回结果的信号，作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; 的返回值。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;注意：在bindBlock中做信号结果的处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bind方法参数&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;RACStreamBindBlock&lt;/strong&gt;:
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typedef RACStream * (^RACStreamBindBlock)(id value, BOOL *stop);&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;参数一(value)&lt;/code&gt;:表示接收到信号的原始值，还没做处理&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;参数二(*stop)&lt;/code&gt;:用来控制绑定Block，如果*stop = yes,那么就会结束绑定。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;返回值&lt;/code&gt;：信号，做好处理，在通过这个信号返回出去，一般使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACReturnSignal&lt;/code&gt;,需要手动导入头文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACReturnSignal.h&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;使用封装好的方法：在返回结果后，拼接。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [_textField.rac_textSignal subscribeNext:^(id x) {
		
      // 在返回结果后，拼接 输出：
      NSLog(@&quot;输出:%@&quot;,x);
		
  }];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;方式二:，使用RAC中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; 方法做处理，在返回结果前，拼接。&lt;/p&gt;

        &lt;p&gt;这里需要手动导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#import &amp;lt;ReactiveCocoa/RACReturnSignal.h&amp;gt;&lt;/code&gt;，才能使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACReturnSignal&lt;/code&gt;&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [[_textField.rac_textSignal bind:^RACStreamBindBlock{
     // 什么时候调用:
     // block作用:表示绑定了一个信号.
		
     return ^RACStream *(id value, BOOL *stop){
		
         // 什么时候调用block:当信号有新的值发出，就会来到这个block。
		
         // block作用:做返回值的处理
		
         // 做好处理，在返回结果前，拼接 输出:
         return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]];
     };
		
  }] subscribeNext:^(id x) {
		
     NSLog(@&quot;%@&quot;,x);
		
  }];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;底层实现&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;源信号调用bind,会重新创建一个绑定信号。&lt;/li&gt;
      &lt;li&gt;当绑定信号被订阅，就会调用绑定信号中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;didSubscribe&lt;/code&gt; ，生成一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindingBlock&lt;/code&gt; 。&lt;/li&gt;
      &lt;li&gt;当源信号有内容发出，就会把内容传递到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindingBlock&lt;/code&gt; 处理，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindingBlock(value,stop)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindingBlock(value,stop)&lt;/code&gt;，会返回一个内容处理完成的信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACReturnSignal&lt;/code&gt;。&lt;/li&gt;
      &lt;li&gt;订阅&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACReturnSignal&lt;/code&gt;，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;映射&quot;&gt;映射&lt;/h4&gt;

&lt;p&gt;映射主要用这两个方法实现：&lt;strong&gt;flattenMap&lt;/strong&gt;,&lt;strong&gt;Map&lt;/strong&gt;,用于把源信号内容映射成新的内容。&lt;/p&gt;

&lt;h6 id=&quot;flattenmap&quot;&gt;flattenMap&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;把源信号的内容映射成一个新的信号，信号可以是任意类型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用步骤&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;传入一个block，block类型是返回值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACStream&lt;/code&gt;，参数value&lt;/li&gt;
      &lt;li&gt;参数value就是源信号的内容，拿到源信号的内容做处理&lt;/li&gt;
      &lt;li&gt;包装成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RACReturnSignal&lt;/code&gt;信号，返回出去。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;监听文本框的内容改变，把结构重新映射成一个新值.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [[_textField.rac_textSignal flattenMap:^RACStream *(id value) {
        
      // block调用时机：信号源发出的时候
        
      // block作用：改变信号的内容
        
      // 返回RACReturnSignal
      return [RACReturnSignal return:[NSString stringWithFormat:@&quot;信号内容：%@&quot;, value]];
        
  }] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;flattenMap&lt;/strong&gt;内部调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; 方法实现的,&lt;strong&gt;flattenMap&lt;/strong&gt;中block的返回值，会作为bind中bindBlock的返回值。&lt;/li&gt;
      &lt;li&gt;当订阅绑定信号，就会生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt;。&lt;/li&gt;
      &lt;li&gt;当源信号发送内容，就会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; bindBlock(value, *stop)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt;，内部就会调用 &lt;strong&gt;flattenMap&lt;/strong&gt; 的 bloc k，&lt;strong&gt;flattenMap&lt;/strong&gt; 的block作用：就是把处理好的数据包装成信号。&lt;/li&gt;
      &lt;li&gt;返回的信号最终会作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; 中的返回信号，当做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; 的返回信号。&lt;/li&gt;
      &lt;li&gt;订阅 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; 的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;map&quot;&gt;Map&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;把源信号的值映射成一个新的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;使用步骤&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;传入一个block,类型是返回对象，参数是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;就是源信号的内容，直接拿到源信号的内容做处理&lt;/li&gt;
      &lt;li&gt;把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;监听文本框的内容改变，把结构重新映射成一个新值.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [[_textField.rac_textSignal map:^id(id value) {
       
     // 拼接完后，返回对象
      return [NSString stringWithFormat:@&quot;信号内容: %@&quot;, value];
        
  }] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;底层实现&lt;/strong&gt;:
    &lt;ol&gt;
      &lt;li&gt;Map底层其实是调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatternMa&lt;/code&gt;p,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt; 中block中的返回的值会作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatternMap&lt;/code&gt; 中block中的值&lt;/li&gt;
      &lt;li&gt;当订阅绑定信号，就会生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;当源信号发送内容，就会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock(value, *stop)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; ，内部就会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flattenMap的block&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flattenMap的block&lt;/code&gt; 内部会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt; 中的block，把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt; 中的block返回的内容包装成返回的信号&lt;/li&gt;
      &lt;li&gt;返回的信号最终会作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; 中的返回信号，当做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; 的返回信号&lt;/li&gt;
      &lt;li&gt;订阅 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bindBlock&lt;/code&gt; 的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;flatternmap-和-map-的区别&quot;&gt;FlatternMap 和 Map 的区别&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;FlatternMap&lt;/strong&gt; 中的Block &lt;strong&gt;返回信号&lt;/strong&gt;。
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt; 中的Block &lt;strong&gt;返回对象&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;开发中，如果信号发出的值 &lt;strong&gt;不是信号&lt;/strong&gt; ，映射一般使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;如果信号发出的值 &lt;strong&gt;是信号&lt;/strong&gt;，映射一般使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FlatternMap&lt;/code&gt;。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signalOfsignals&lt;/code&gt;用 &lt;strong&gt;FlatternMap&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 创建信号中的信号
  RACSubject *signalOfsignals = [RACSubject subject];
  RACSubject *signal = [RACSubject subject];

  [[signalOfsignals flattenMap:^RACStream *(id value) {

   // 当signalOfsignals的signals发出信号才会调用

      return value;

  }] subscribeNext:^(id x) {

      // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。
      // 也就是flattenMap返回的信号发出内容，才会调用。

      NSLog(@&quot;signalOfsignals：%@&quot;,x);
  }];

  // 信号的信号发送信号
  [signalOfsignals sendNext:signal];

  // 信号发送内容
  [signal sendNext:@&quot;hi&quot;];
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;组合&quot;&gt;组合&lt;/h4&gt;

&lt;p&gt;组合就是将多个信号按照某种规则进行拼接，合成新的信号。&lt;/p&gt;

&lt;h6 id=&quot;concat&quot;&gt;concat&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;按&lt;strong&gt;顺序拼接&lt;/strong&gt;信号，当多个信号发出的时候，有顺序的接收信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;底层实现&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;当拼接信号被订阅，就会调用拼接信号的didSubscribe&lt;/li&gt;
      &lt;li&gt;didSubscribe中，会先订阅第一个源信号（signalA）&lt;/li&gt;
      &lt;li&gt;会执行第一个源信号（signalA）的didSubscribe&lt;/li&gt;
      &lt;li&gt;第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来.&lt;/li&gt;
      &lt;li&gt;第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。&lt;/li&gt;
      &lt;li&gt;订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe&lt;/li&gt;
      &lt;li&gt;第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用步骤&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concat:&lt;/code&gt;拼接信号&lt;/li&gt;
      &lt;li&gt;订阅拼接信号，内部会自动按拼接顺序订阅信号&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;拼接信号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signalA&lt;/code&gt;、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signalB&lt;/code&gt;、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signalC&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;Hello&quot;];
        
      [subscriber sendCompleted];
        
      return nil;
  }];
    
  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;World&quot;];
        
      [subscriber sendCompleted];
        
      return nil;
  }];
    
  RACSignal *signalC = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;!&quot;];
        
      [subscriber sendCompleted];
        
      return nil;
  }];
    
  // 拼接 A B, 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。
  RACSignal *concatSignalAB = [signalA concat:signalB];
    
  // A B + C
  RACSignal *concatSignalABC = [concatSignalAB concat:signalC];
    
    
  // 订阅拼接的信号, 内部会按顺序订阅 A-&amp;gt;B-&amp;gt;C
  // 注意：第一个信号必须发送完成，第二个信号才会被激活...
  [concatSignalABC subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;then&quot;&gt;then&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用于连接两个信号，当第一个信号完成，才会连接then返回的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;先过滤掉之前的信号发出的值&lt;/li&gt;
      &lt;li&gt;使用concat连接then返回的信号&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [[[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
      
    [subscriber sendNext:@1];
      
    [subscriber sendCompleted];
      
    return nil;
      
  }] then:^RACSignal *{
      
    	return [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
          
        [subscriber sendNext:@2];
          
        return nil;
    }];
      
  }] subscribeNext:^(id x) {
      
    // 只能接收到第二个信号的值，也就是then返回信号的值
    NSLog(@&quot;%@&quot;, x);
      
  }];
    
  ///
  输出：2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;注意使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;then&lt;/code&gt;，之前信号的值会被忽略掉.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;merge&quot;&gt;merge&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;合并信号,任何一个信号发送数据，都能监听到.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。&lt;/li&gt;
      &lt;li&gt;每发出一个信号，这个信号就会被订阅&lt;/li&gt;
      &lt;li&gt;也就是合并信号一被订阅，就会订阅里面所有的信号。&lt;/li&gt;
      &lt;li&gt;只要有一个信号被发出就会被监听。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;A&quot;];
        
      return nil;
  }];

  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;B&quot;];
        
      return nil;
  }];

  // 合并信号, 任何一个信号发送数据，都能监听到
  RACSignal *mergeSianl = [signalA merge:signalB];

  [mergeSianl subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
    
  // 输出
  2017-01-03 13:29:08.013 ReactiveCocoa进阶[3627:718315] A
  2017-01-03 13:29:08.014 ReactiveCocoa进阶[3627:718315] B

    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;zip&quot;&gt;zip&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;把两个信号压缩成一个信号，只有当两个信号 &lt;strong&gt;同时&lt;/strong&gt; 发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;定义压缩信号，内部就会自动订阅signalA，signalB&lt;/li&gt;
      &lt;li&gt;每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把每个信号 第一次 发出的值包装成元组发出&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;A1&quot;];
      [subscriber sendNext:@&quot;A2&quot;];
        
      return nil;
  }];
    
  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;B1&quot;];
      [subscriber sendNext:@&quot;B2&quot;];
      [subscriber sendNext:@&quot;B3&quot;];
        
      return nil;
  }];
    
  RACSignal *zipSignal = [signalA zipWith:signalB];
    
  [zipSignal subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
	
  // 输出
  2017-01-03 13:48:09.234 ReactiveCocoa进阶[3997:789720] zipWith: &amp;lt;RACTuple: 0x600000004df0&amp;gt; (
  A1,
  B1
  )
  2017-01-03 13:48:09.234 ReactiveCocoa进阶[3997:789720] zipWith: &amp;lt;RACTuple: 0x608000003410&amp;gt; (
  A2,
  B2
  )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;combinelatest&quot;&gt;combineLatest&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;将多个信号合并起来，并且拿到各个信号最后一个值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

 	1. 当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。
 	2. 并且把两个信号的 最后一次 发送的值组合成元组发出。

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;A1&quot;];
      [subscriber sendNext:@&quot;A2&quot;];
        
      return nil;
  }];
    
  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;B1&quot;];
      [subscriber sendNext:@&quot;B2&quot;];
      [subscriber sendNext:@&quot;B3&quot;];
        
      return nil;
  }];
    
  RACSignal *combineSianal = [signalA combineLatestWith:signalB];
    
  [combineSianal subscribeNext:^(id x) {
        
      NSLog(@&quot;combineLatest:%@&quot;, x);
  }];
	
  // 输出
  2017-01-03 13:48:09.235 ReactiveCocoa进阶[3997:789720] combineLatest:&amp;lt;RACTuple: 0x60800000e150&amp;gt; (
  A2,
  B1
  )
  2017-01-03 13:48:09.235 ReactiveCocoa进阶[3997:789720] combineLatest:&amp;lt;RACTuple: 0x600000004db0&amp;gt; (
  A2,
  B2
  )
  2017-01-03 13:48:09.236 ReactiveCocoa进阶[3997:789720] combineLatest:&amp;lt;RACTuple: 0x60800000e180&amp;gt; (
  A2,
  B3
  )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;combineLatest&lt;/strong&gt;与&lt;strong&gt;zip&lt;/strong&gt;用法相似，必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。&lt;/p&gt;

    &lt;p&gt;区别看下图：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006y8lVagw1fbdf6cyez6j30id0kkabf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;reduce&quot;&gt;reduce&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;把信号发出元组的值聚合成一个值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

 	1. 订阅聚合信号，
 	2. 每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;常见的用法，（先组合在聚合）&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combineLatest:(id&amp;lt;NSFastEnumeration&amp;gt;)signals reduce:(id (^)())reduceBlock&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;reduce中的block简介:&lt;/p&gt;

    &lt;p&gt;reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容
   reduceblcok的返回值：聚合信号之后的内容。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;A1&quot;];
      [subscriber sendNext:@&quot;A2&quot;];
        
      return nil;
  }];
    
  RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;B1&quot;];
      [subscriber sendNext:@&quot;B2&quot;];
      [subscriber sendNext:@&quot;B3&quot;];
        
      return nil;
  }];
    
    
  RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA, signalB] reduce:^id(NSString *str1, NSString *str2){
        
      return [NSString stringWithFormat:@&quot;%@ %@&quot;, str1, str2];
  }];
    
  [reduceSignal subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
    
  // 输出
  2017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B1
  2017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B2
  2017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B3
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;过滤&quot;&gt;过滤&lt;/h4&gt;

&lt;p&gt;过滤就是过滤信号中的 特定值 ，或者过滤指定 发送次数 的信号。&lt;/p&gt;

&lt;h6 id=&quot;filter&quot;&gt;filter&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;过滤信号，使用它可以获取满足条件的信号.&lt;/p&gt;

    &lt;p&gt;block的返回值是Bool值，返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NO&lt;/code&gt;则过滤该信号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 过滤:
  // 每次信号发出，会先执行过滤条件判断.
  [[_textField.rac_textSignal filter:^BOOL(NSString *value) {
        
      NSLog(@&quot;原信号: %@&quot;, value);

      // 过滤 长度 &amp;lt;= 3 的信号
      return value.length &amp;gt; 3;
        
  }] subscribeNext:^(id x) {
        
      NSLog(@&quot;长度大于3的信号：%@&quot;, x);
  }];
    
  // 在_textField中输出12345
  // 输出
  2017-01-03 16:36:54.938 ReactiveCocoa进阶[4714:1552910] 原信号: 1
  2017-01-03 16:36:55.383 ReactiveCocoa进阶[4714:1552910] 原信号: 12
  2017-01-03 16:36:55.706 ReactiveCocoa进阶[4714:1552910] 原信号: 123
  2017-01-03 16:36:56.842 ReactiveCocoa进阶[4714:1552910] 原信号: 1234
  2017-01-03 16:36:56.842 ReactiveCocoa进阶[4714:1552910] 长度大于3的信号：1234
  2017-01-03 16:36:58.350 ReactiveCocoa进阶[4714:1552910] 原信号: 12345
  2017-01-03 16:36:58.351 ReactiveCocoa进阶[4714:1552910] 长度大于3的信号：12345
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;ignore&quot;&gt;ignore&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;忽略某些信号.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;忽略某些值的信号.&lt;/p&gt;

    &lt;p&gt;底层调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter&lt;/code&gt; 与 过滤值进行比较，若相等返回则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NO&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;```
	// 内部调用filter过滤，忽略掉字符为 @“1”的值
[[_textField.rac_textSignal ignore:@”1”] subscribeNext:^(id x) {&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

 	 NSLog(@”%@”,x);
&lt;p&gt;}];&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;distinctuntilchanged&quot;&gt;distinctUntilChanged&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;,x);
  }];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;skip&quot;&gt;skip&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;跳过 &lt;strong&gt;第N次&lt;/strong&gt; 的发送的信号.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 表示输入第一次，不会被监听到，跳过第一次发出的信号
[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) {

 NSLog(@&quot;%@&quot;,x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;take&quot;&gt;take&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;取 &lt;strong&gt;前N次&lt;/strong&gt; 的发送的信号.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSubject *subject = [RACSubject subject] ;
    
  // 取 前两次 发送的信号
  [[subject take:2] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
    
  [subject sendNext:@1];
  [subject sendNext:@2];
  [subject sendNext:@3];
    
  // 输出
  2017-01-03 17:35:54.566 ReactiveCocoa进阶[4969:1677908] 1
  2017-01-03 17:35:54.567 ReactiveCocoa进阶[4969:1677908] 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;takelast&quot;&gt;takeLast&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;取 &lt;strong&gt;最后N次&lt;/strong&gt; 的发送的信号&lt;/p&gt;

    &lt;p&gt;前提条件，订阅者必须调用完成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendCompleted&lt;/code&gt;，因为只有完成，就知道总共有多少信号.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSubject *subject = [RACSubject subject] ;
    
  // 取 后两次 发送的信号
  [[subject takeLast:2] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
    
  [subject sendNext:@1];
  [subject sendNext:@2];
  [subject sendNext:@3];
    
  // 必须 跳用完成
  [subject sendCompleted];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;takeuntil&quot;&gt;takeUntil&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;获取信号直到某个信号执行完成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 监听文本框的改变直到当前对象被销毁
[_textField.rac_textSignal takeUntil:self.rac_willDeallocSignal];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;switchtolatest&quot;&gt;switchToLatest&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;switchToLatest：只能用于信号中的信号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSubject *signalOfSignals = [RACSubject subject];
  RACSubject *signal = [RACSubject subject];
    
  // 获取信号中信号最近发出信号，订阅最近发出的信号。
  [signalOfSignals.switchToLatest subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
    
  [signalOfSignals sendNext:signal];
  [signal sendNext:@1];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;秩序&quot;&gt;秩序&lt;/h4&gt;

&lt;p&gt;秩序包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doNext&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doCompleted&lt;/code&gt; 这两个方法，主要是在 执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendNext&lt;/code&gt; 或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendCompleted&lt;/code&gt;之前，先执行这些方法中Block。&lt;/p&gt;

&lt;h6 id=&quot;donext&quot;&gt;doNext&lt;/h6&gt;

&lt;p&gt;执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendNext&lt;/code&gt;之前，会先执行这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doNext&lt;/code&gt;的 Block&lt;/p&gt;

&lt;h6 id=&quot;docompleted&quot;&gt;doCompleted&lt;/h6&gt;

&lt;p&gt;执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendCompleted&lt;/code&gt;之前，会先执行这&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doCompleted&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Block&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[[[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    
    [subscriber sendNext:@&quot;hi&quot;];
    
    [subscriber sendCompleted];
    
    return nil;
    
}] doNext:^(id x) {
    
    // 执行 [subscriber sendNext:@&quot;hi&quot;] 之前会调用这个 Block
    NSLog(@&quot;doNext&quot;);
    
}] doCompleted:^{
    
    // 执行 [subscriber sendCompleted] 之前会调用这 Block
    NSLog(@&quot;doCompleted&quot;);
}] subscribeNext:^(id x) {
    
    NSLog(@&quot;%@&quot;, x);
}];
    

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;线程&quot;&gt;线程&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;ReactiveCocoa&lt;/strong&gt; 中的线程操作 包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deliverOn&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subscribeOn&lt;/code&gt;这两种，将 &lt;em&gt;传递的内容&lt;/em&gt; 或 创建信号时 &lt;em&gt;block中的代码&lt;/em&gt; 切换到指定的线程中执行。&lt;/p&gt;

&lt;h6 id=&quot;deliveron&quot;&gt;deliverOn&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 在子线程中执行
  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
      [[[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
          NSLog(@&quot;%@&quot;, [NSThread currentThread]);
            
          [subscriber sendNext:@123];
            
          [subscriber sendCompleted];
            
          return nil;
      }]
        deliverOn:[RACScheduler mainThreadScheduler]]
          
       subscribeNext:^(id x) {
         
           NSLog(@&quot;%@&quot;, x);
             
           NSLog(@&quot;%@&quot;, [NSThread currentThread]);
       }];
  });
    
  // 输出
2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224535] &amp;lt;NSThread: 0x608000270f00&amp;gt;{number = 3, name = (null)}
2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224482] 123
2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224482] &amp;lt;NSThread: 0x600000079bc0&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;可以看到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;副作用&lt;/code&gt;在 &lt;em&gt;子线程&lt;/em&gt; 中执行，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;传递的内容&lt;/code&gt; 在 &lt;em&gt;主线程&lt;/em&gt; 中接收&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;subscribeon&quot;&gt;subscribeOn&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;subscribeOn&lt;/strong&gt;则是将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;内容传递&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;副作用&lt;/code&gt; 都会切换到指定线程中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
      [[[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
          NSLog(@&quot;%@&quot;, [NSThread currentThread]);
            
          [subscriber sendNext:@123];
            
          [subscriber sendCompleted];
            
          return nil;
      }]
        subscribeOn:[RACScheduler mainThreadScheduler]] //传递的内容到主线程中
       subscribeNext:^(id x) {
         
           NSLog(@&quot;%@&quot;, x);
             
           NSLog(@&quot;%@&quot;, [NSThread currentThread]);
       }];
  });	
  //
2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] &amp;lt;NSThread: 0x608000077640&amp;gt;{number = 1, name = main}
2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] 123
2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] &amp;lt;NSThread: 0x608000077640&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;内容传递&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;副作用&lt;/code&gt; 都切换到了 &lt;em&gt;主线程&lt;/em&gt; 执行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;时间&quot;&gt;时间&lt;/h4&gt;

&lt;p&gt;时间操作就会设置信号超时，定时和延时。&lt;/p&gt;

&lt;h6 id=&quot;interval-定时&quot;&gt;interval 定时&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;定时：每隔一段时间发出信号&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 每隔1秒发送信号，指定当前线程执行
  [[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) {
        
      NSLog(@&quot;定时:%@&quot;, x);
  }];
    
  // 输出
  2017-01-04 13:48:55.196 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:55 +0000
  2017-01-04 13:48:56.195 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:56 +0000
  2017-01-04 13:48:57.196 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:57 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;timeout-超时&quot;&gt;timeout 超时&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;超时，可以让一个信号在一定的时间后，自动报错。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      // 不发送信号，模拟超时状态
      // [subscriber sendNext:@&quot;hello&quot;];
      //[subscriber sendCompleted];
        
      return nil;
  }] timeout:1 onScheduler:[RACScheduler currentScheduler]];// 设置1秒超时
    
  [signal subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  } error:^(NSError *error) {
        
      NSLog(@&quot;%@&quot;, error);
  }];
    
  // 执行代码 1秒后 输出：
  2017-01-04 13:48:55.195 ReactiveCocoa进阶[1980:492724] Error Domain=RACSignalErrorDomain Code=1 &quot;(null)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;delay-延时&quot;&gt;delay 延时&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;延时，延迟一段时间后发送信号&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSignal *signal2 = [[[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@&quot;延迟输出&quot;];
        
      return nil;
  }] delay:2] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
    
  // 执行代码 2秒后 输出
  2017-01-04 13:55:23.751 ReactiveCocoa进阶[2030:525038] 延迟输出
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;重复&quot;&gt;重复&lt;/h4&gt;

&lt;h6 id=&quot;retry&quot;&gt;retry&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;重试：只要 发送错误 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendError:&lt;/code&gt;,就会 重新执行 创建信号的Block 直到成功&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  __block int i = 0;
    
  [[[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      if (i == 5) {
            
          [subscriber sendNext:@&quot;Hello&quot;];
            
      } else {
            
          // 发送错误
          NSLog(@&quot;收到错误:%d&quot;, i);
          [subscriber sendError:nil];
      }
        
      i++;
        
      return nil;
        
  }] retry] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
        
  } error:^(NSError *error) {
        
      NSLog(@&quot;%@&quot;, error);
        
  }];

  // 输出
2017-01-04 14:36:51.594 ReactiveCocoa进阶[2443:667226] 收到错误信息:0
2017-01-04 14:36:51.595 ReactiveCocoa进阶[2443:667226] 收到错误信息:1
2017-01-04 14:36:51.595 ReactiveCocoa进阶[2443:667226] 收到错误信息:2
2017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] 收到错误信息:3
2017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] 收到错误信息:4
2017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] Hello

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;replay&quot;&gt;replay&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;重放：当一个信号被多次订阅,反复播放内容&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
      [subscriber sendNext:@1];
      [subscriber sendNext:@2];
        
      return nil;
  }] replay];
    
  [signal subscribeNext:^(id x) {
      NSLog(@&quot;%@&quot;, x);
  }];
    
  [signal subscribeNext:^(id x) {
      NSLog(@&quot;%@&quot;, x);
  }];
    
  // 输出
2017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 1
2017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 2
2017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 1
2017-01-04 14:51:01.935 ReactiveCocoa进阶[2544:706740] 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;throttle&quot;&gt;throttle&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RACSubject *subject = [RACSubject subject];
    
  // 节流1秒，1秒后接收最后一个发送的信号
  [[subject throttle:1] subscribeNext:^(id x) {
        
      NSLog(@&quot;%@&quot;, x);
  }];
    
  [subject sendNext:@1];
  [subject sendNext:@2];
  [subject sendNext:@3];
    
  // 输出
  2017-01-04 15:02:37.543 ReactiveCocoa进阶[2731:758193] 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;mvvm架构思想&quot;&gt;MVVM架构思想&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;程序为什么要有架构？便于程序开发与维护.&lt;/p&gt;

&lt;h4 id=&quot;常见的架构&quot;&gt;常见的架构&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MVC&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;M:模型 V:视图 C:控制器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MVVM&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;M:模型 V:视图+控制器 VM:视图模型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MVCS&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;M:模型 V:视图 C:控制器 C:服务类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20140703/9016.html&quot;&gt;&lt;strong&gt;VIPER&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;V:视图 I:交互器 P:展示器 E:实体 R:路由&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mvvm介绍&quot;&gt;MVVM介绍&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;模型(M):保存视图数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视图+控制器(V):展示内容 + 如何展示&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;实战一登录界面&quot;&gt;实战一：登录界面&lt;/h1&gt;

&lt;h4 id=&quot;需求&quot;&gt;需求&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;监听两个文本框的内容&lt;/li&gt;
  &lt;li&gt;有内容登录按键才允许按钮点击&lt;/li&gt;
  &lt;li&gt;返回登录结果&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;界面的所有业务逻辑都交给控制器做处理&lt;/li&gt;
  &lt;li&gt;在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;步骤&quot;&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;创建LoginViewModel类，处理登录界面业务逻辑.&lt;/li&gt;
  &lt;li&gt;这个类里面应该保存着账号的信息，创建一个账号Account模型&lt;/li&gt;
  &lt;li&gt;LoginViewModel应该保存着账号信息Account模型。&lt;/li&gt;
  &lt;li&gt;需要时刻监听Account模型中的账号和密码的改变，怎么监听？&lt;/li&gt;
  &lt;li&gt;在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。&lt;/li&gt;
  &lt;li&gt;每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号.&lt;/li&gt;
  &lt;li&gt;这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号.&lt;/li&gt;
  &lt;li&gt;监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑.&lt;/li&gt;
  &lt;li&gt;执行命令，把数据包装成信号传递出去&lt;/li&gt;
  &lt;li&gt;监听命令中信号的数据传递&lt;/li&gt;
  &lt;li&gt;监听命令的执行时刻&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;运行效果&quot;&gt;运行效果&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fbgvoh8yu6j30bj0l43yz.jpg&quot; alt=&quot;登录界面&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyViewController.m&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;MyViewController.h&quot;
#import &quot;LoginViewModel.h&quot;

@interface MyViewController ()

@property (nonatomic, strong) LoginViewModel *loginViewModel;

@property (weak, nonatomic) IBOutlet UITextField *accountField;

@property (weak, nonatomic) IBOutlet UITextField *pwdField;

@property (weak, nonatomic) IBOutlet UIButton *loginBtn;

@end

@implementation MyViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self bindModel];
    
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}



// 视图模型绑定
- (void)bindModel {

    // 给模型的属性绑定信号
    //
    RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal;
    RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal;
    
    RAC(self.loginBtn, enabled) = self.loginViewModel.enableLoginSignal;
    
    // 监听登录点击
    [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {
        
        [self.loginViewModel.LoginCommand execute:nil];
    }];
    
}
- (IBAction)btnTap:(id)sender {
    
    
}

#pragma mark - lazyLoad

- (LoginViewModel *)loginViewModel {
    
    if (nil == _loginViewModel) {
        _loginViewModel = [[LoginViewModel alloc] init];
    }
    
    return _loginViewModel;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoginViewModel.h&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface Account : NSObject

@property (nonatomic, strong) NSString *account;
@property (nonatomic, strong) NSString *pwd;

@end


@interface LoginViewModel : UIViewController

@property (nonatomic, strong) Account *account;

// 是否允许登录的信号
@property (nonatomic, strong, readonly) RACSignal *enableLoginSignal;

@property (nonatomic, strong, readonly) RACCommand *LoginCommand;

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoginViewModel.m&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;LoginViewModel.h&quot;

@implementation Account

@end


@interface LoginViewModel ()

@end

@implementation LoginViewModel

- (instancetype)init {
    
    if (self = [super init]) {
        [self initialBind];
    }
    return self;
}

- (void)initialBind {

    // 监听账号属性改变， 把他们合成一个信号
    _enableLoginSignal = [RACSubject combineLatest:@[RACObserve(self.account, account), RACObserve(self.account, pwd)] reduce:^id(NSString *accout, NSString *pwd){
        
        return @(accout.length &amp;amp;&amp;amp; pwd.length);
    }];
    
    // 处理业务逻辑
    _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
        
        NSLog(@&quot;点击了登录&quot;);
        return [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
            
            // 模仿网络延迟

            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                
                // 返回登录成功 发送成功信号
                [subscriber sendNext:@&quot;登录成功&quot;];
            });
            
            return nil;
        }];
    }];
    
    
    // 监听登录产生的数据
    [_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) {
       
        if ([x isEqualToString:@&quot;登录成功&quot;]) {
            NSLog(@&quot;登录成功&quot;);
        }
        
    }];
    
    [[_LoginCommand.executing skip:1] subscribeNext:^(id x) {
        
        if ([x isEqualToNumber:@(YES)]) {
            
            NSLog(@&quot;正在登陆...&quot;);
        } else {
            
        // 登录成功
        NSLog(@&quot;登陆成功&quot;);
        
        }
        
    }];
}

#pragma mark - lazyLoad

- (Account *)account
{
    if (_account == nil) {
        _account = [[Account alloc] init];
    }
    return _account;
}

- (void)viewDidLoad {
    [super viewDidLoad];
    
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;实战二网络请求数据&quot;&gt;实战二：网络请求数据&lt;/h1&gt;

&lt;h4 id=&quot;需求-1&quot;&gt;需求&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;请求一段网络数据，将请求到的数据在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tableView&lt;/code&gt;上展示&lt;/li&gt;
  &lt;li&gt;该数据为豆瓣图书的搜索返回结果，URL：url:https://api.douban.com/v2/book/search?q=悟空传&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;分析-1&quot;&gt;分析&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;界面的所有业务逻辑都交给&lt;strong&gt;控制器&lt;/strong&gt;做处理&lt;/li&gt;
  &lt;li&gt;网络请求交给&lt;strong&gt;MV&lt;/strong&gt;模型处理&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;步骤-1&quot;&gt;步骤&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑&lt;/li&gt;
  &lt;li&gt;VM提供一个命令，处理请求业务逻辑&lt;/li&gt;
  &lt;li&gt;在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。&lt;/li&gt;
  &lt;li&gt;请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;

&lt;p&gt;网络请求与图片缓存用到了&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;AFNetworking&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;,自行在Pods中导入。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;platform :ios, &apos;8.0&apos;

target &apos;ReactiveCocoa进阶&apos; do

use_frameworks!
pod &apos;ReactiveCocoa&apos;, &apos;~&amp;gt; 2.5&apos;
pod &apos;AFNetworking&apos;
pod &apos;SDWebImage&apos;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;运行效果-1&quot;&gt;运行效果&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fbgw1xnz74j30bj0l4408.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代码-1&quot;&gt;代码&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SearchViewController.m&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;SearchViewController.h&quot;
#import &quot;RequestViewModel.h&quot;

@interface SearchViewController ()&amp;lt;UITableViewDataSource&amp;gt;

@property (nonatomic, strong) UITableView *tableView;

@property (nonatomic, strong) RequestViewModel *requesViewModel;

@end

@implementation SearchViewController

- (RequestViewModel *)requesViewModel
{
    if (_requesViewModel == nil) {
        _requesViewModel = [[RequestViewModel alloc] init];
    }
    return _requesViewModel;
}

- (void)viewDidLoad {
    [super viewDidLoad];
    
    
    self.tableView = [[UITableView alloc] initWithFrame:self.view.frame];
    
    self.tableView.dataSource = self;
    
    [self.view addSubview:self.tableView];
    
    //
    RACSignal *requesSiganl = [self.requesViewModel.reuqesCommand execute:nil];
    
    [requesSiganl subscribeNext:^(NSArray *x) {
        
        self.requesViewModel.models = x;
        
        [self.tableView reloadData];
    }];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return self.requesViewModel.models.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *ID = @&quot;cell&quot;;
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
    if (cell == nil) {
        
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];
    }
    
    Book *book = self.requesViewModel.models[indexPath.row];
    cell.detailTextLabel.text = book.subtitle;
    cell.textLabel.text = book.title;
    
    [cell.imageView sd_setImageWithURL:[NSURL URLWithString:book.image] placeholderImage:[UIImage imageNamed:@&quot;cellImage&quot;]];
    
    
    return cell;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestViewModel.h&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Book : NSObject

@property (nonatomic, copy) NSString *subtitle;
@property (nonatomic, copy) NSString *title;
@property (nonatomic, copy) NSString *image;

@end

@interface RequestViewModel : NSObject

// 请求命令
@property (nonatomic, strong, readonly) RACCommand *reuqesCommand;

//模型数组
@property (nonatomic, strong) NSArray *models;


@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestViewModel.m&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;RequestViewModel.h&quot;

@implementation Book

- (instancetype)initWithValue:(NSDictionary *)value {
    
    if (self = [super init]) {
        
        self.title = value[@&quot;title&quot;];
        self.subtitle = value[@&quot;subtitle&quot;];
        self.image = value[@&quot;image&quot;];
    }
    return self;
}

+ (Book *)bookWithDict:(NSDictionary *)value {
    
    return [[self alloc] initWithValue:value];
}



@end

@implementation RequestViewModel

- (instancetype)init
{
    if (self = [super init]) {
        
        [self initialBind];
    }
    return self;
}


- (void)initialBind
{
    _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
        
      RACSignal *requestSiganl = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
          
          NSMutableDictionary *parameters = [NSMutableDictionary dictionary];
          parameters[@&quot;q&quot;] = @&quot;悟空传&quot;;
          
          //
          [[AFHTTPSessionManager manager] GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) {
              
              NSLog(@&quot;downloadProgress: %@&quot;, downloadProgress);
          } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
              
              // 数据请求成功就讲数据发送出去
              NSLog(@&quot;responseObject:%@&quot;, responseObject);
              
              [subscriber sendNext:responseObject];
              
              [subscriber sendCompleted];
              
          } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
              
              NSLog(@&quot;error: %@&quot;, error);
          }];
          
          
         return nil;
      }];
        
        // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去
        return [requestSiganl map:^id(NSDictionary *value) {
            
            NSMutableArray *dictArr = value[@&quot;books&quot;];
            
            NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) {
                
                return [Book bookWithDict:value];
                
            }] array];
            
            return modelArr;
            
        }];
        
    }];
}


@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;最后附上GitHub：&lt;a href=&quot;https://github.com/qiubaiying/ReactiveCocoa_Demo&quot;&gt;https://github.com/qiubaiying/ReactiveCocoa_Demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 06 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/06/ReactiveCocoa-%E8%BF%9B%E9%98%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/06/ReactiveCocoa-%E8%BF%9B%E9%98%B6/</guid>
        
        <category>iOS</category>
        
        <category>ReactiveCocoa</category>
        
        <category>函数式编程</category>
        
        <category>开源框架</category>
        
        
      </item>
    
  </channel>
</rss>
